package org.opentestsystem.ss.contentspecid;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Triple;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Stream;

import static java.lang.String.format;
import static java.lang.String.join;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Created by Greg Charles on 11/5/18.
 */
class ContentSpecIdTest {
    private static final String UTF_8_BOM = "\u00EF\u00BB\u00BF";
    private static final String UTF_16_BOM = "\uFEFF";

    private static final String[] TEST_FILES = {
            "AA_Tests.txt",
            "LegacyIdsInUse.txt",
            "ElaLegacyIdsFromCoreStandards.txt",
            "MathLegacyIdsFromCoreStandards.txt",
            "ElaEnhancedIdsFromCASE.txt",
            "MathEnhancedIdsFromCASE.txt"
    };

    private static final String RESOURCE_DATA_FOLDER = "/testdata/";

    private static final Map<String, Counters> countersMap = new LinkedHashMap<>();

    // @TODO: check against refactor
    private static final ContentSpecIdParser newParser = new ContentSpecIdParser();

    @BeforeAll
    static void setUpCounters() {
        countersMap.clear();
        for(String fileName : TEST_FILES) {
            countersMap.put(fileName, new Counters());
        }
    }

    @AfterAll
    static void outputCounters() {
        System.out.println("--------------------------------------------------------");
        countersMap.forEach((fileName, counters) -> {
            System.out.println("Testing IDs in " + fileName + ":");
            System.out.println(counters);
            System.out.println("--------------------------------------------------------");
        });
    }

    @ParameterizedTest
    @MethodSource("loadContentSpecIds")
    void shouldParseIds(Triple<ContentSpecGrade,String,String> data) throws Throwable {

        final ContentSpecGrade defaultGrade = data.getLeft();
        final String idString = data.getMiddle();
        final String sourceFile = data.getRight();
        final Counters counters = countersMap.get(sourceFile);
        counters.incrementIdCount();

        try {
            // Parse the ID and check for errors
            ContentSpecId id = ContentSpecId.tryParse(idString, defaultGrade);
            assertThat("Error parsing " + defaultGrade + "," + idString + ": " + id.getParseErrorDescription(),
                    id.getParseErrorSeverity(), is(ErrorSeverity.NO_ERROR));

            boolean isEnhanced = id.getParseFormat() == ContentSpecIdFormat.ENHANCED;

            // TODO: check against refactor
            ContentSpecIdFormat format = newParser.getFormatType(idString);
            assertThat(format, is(id.getParseFormat()));
            if (format == ContentSpecIdFormat.ENHANCED) {
                ContentSpecIdModel newId = newParser.parse(idString);
                refactoringCheck(idString, id, newId);
                assertThat("New round trip failure", newParser.formatId(newId), is(idString));
            }


            // Check for format-ability
            ErrorSeverity errorSeverity = id.validateFor(id.getParseFormat());
            assertThat("Validation error: " + id.getValidationErrorDescription(),
                    errorSeverity, is(ErrorSeverity.NO_ERROR));

            String compId = (id.getParseFormat() != ContentSpecIdFormat.ENHANCED)
                    ? remedyMissingGrade(idString, defaultGrade)
                    : idString;

            // Check for round-trip match
            String roundTrip = id.toString();
            assertThat("   Formatted ID doesn't match:", roundTrip, is(compId));


            // Check conversions between enhanced and legacy formats
            checkLegacyConversions(id, compId);

            if (isEnhanced) {
                counters.incrementEnhancedFormatCount();
            } else {
                counters.incrementLegacyFormatCount();
            }
        } catch (Throwable t) {
            counters.incrementErrorCount();
            throw t;
        }
    }

    // TODO: check against refactor
    private void refactoringCheck(String idString, ContentSpecId id, ContentSpecIdModel newId) {
        assertThat("Fail " + idString,id.getSubject() == newId.getSubject());
        assertThat("Fail " + idString,id.getGrade() == newId.getGrade());
        assertThat("Fail " + idString,id.getClaim() == newId.getClaim());
        assertThat("Fail " + idString, myEquals(id.getTarget(), newId.getTarget()));
        assertThat("Fail " + idString, myEquals(id.getCcss(), newId.getCcss()));
        assertThat("Fail " + idString, myEquals(id.getDomain(), newId.getDomain()));
    }

    private boolean myEquals(String a, String b) {
        return (a == null && b == null) || (StringUtils.equals(a, b));
    }

    private void checkLegacyConversions(final ContentSpecId id, final String compId) {
        // If claim or target is not specfied then it cannot be converted to
        // legacy format. Do not perform the test.
        if (id.getParseFormat() == ContentSpecIdFormat.ENHANCED
                && (id.getClaim() == ContentSpecClaim.UNSPECIFIED || isBlank(id.getTarget()))) {
            return;
        }


        // Format legacy as enhnaced and enhanced as legacy
        ContentSpecIdFormat originalFormat = id.getParseFormat();
        ContentSpecIdFormat convertFormat;

        switch (originalFormat) {
            case ELA_V1:
            case MATH_V4:
            case MATH_V5:
            case MATH_V6:
                convertFormat = ContentSpecIdFormat.ENHANCED;
                break;

            case ENHANCED:
                switch (id.getSubject()) {
                    case ELA:
                        convertFormat = ContentSpecIdFormat.ELA_V1;
                        break;

                    case MATH:
                        convertFormat = ContentSpecIdFormat.MATH_V4;
                        break;

                    default:
                        throw new IllegalArgumentException("Unexpected subject.");
                }
                break;

            default:
                throw new IllegalArgumentException("Unexpected format.");
        }

        // See if can be reformatted to target format
        ErrorSeverity errorSeverity = id.validateFor(convertFormat);
        String reason = format("Cannot convertSubject from '%s to '%s': %s",
                id.getParseFormat(), convertFormat, id.getValidationErrorDescription());

        assertThat(reason, errorSeverity, is(ErrorSeverity.NO_ERROR));

        try {
            // Round-trip through conversion format
            id.setParseFormat(convertFormat);
            String convertedIdStr = id.toString();
            ContentSpecId convertedId = ContentSpecId.tryParse(convertedIdStr);

            reason = format("Failed to parse %s with converted format: %s",
                    convertedIdStr, convertedId.getParseErrorDescription());
            assertThat(reason, convertedId.isParseSucceeded());

            reason = format("Converted ID from %s is not equal to original.", convertedIdStr);
            assertThat(reason, convertedId, is(id));


            errorSeverity = convertedId.validateFor(originalFormat);
            reason = format("Cannot convertSubject from '%s'to original '%s': %s",
                    convertFormat, originalFormat, convertedId.getValidationErrorDescription());
            assertThat(reason, errorSeverity, is(ErrorSeverity.NO_ERROR));

            convertedId.setParseFormat(originalFormat);
            String roundTrip = convertedId.toString();

            reason = format("ID %s doesn't match when round-tripped through alternative format: %s",
                    convertedIdStr, roundTrip);
            assertThat(reason, compId.equalsIgnoreCase(roundTrip));
        } finally {
            // Restore the original format to the ID.
            id.setParseFormat(originalFormat);
        }
    }

    private static Stream<Triple<ContentSpecGrade,String,String>> loadContentSpecIds() {
        return Arrays.stream(TEST_FILES)
                .flatMap(ContentSpecIdTest::loadContentSpecIdsFromFile);
    }

    private static Stream<Triple<ContentSpecGrade, String, String>> loadContentSpecIdsFromFile(final String fileName) {
        try {
            return Files
                    .lines(getFile(fileName).toPath())
                    .filter(StringUtils::isNotBlank)
//                    .limit(10);
                    .map(String::trim)
                    .map(ContentSpecIdTest::handleBom)
                    .map(line -> parseFileLine(line, fileName));
        } catch (IOException e) {
            fail("File " + fileName + " not found");
            return Stream.of();
        }
    }

    private static File getFile(String fileName) {
        URL url = Object.class.getResource(RESOURCE_DATA_FOLDER + fileName);
        assertNotNull(url, "File " + fileName + " not found");
        return new File(url.getFile());
    }

    private static Triple<ContentSpecGrade, String, String> parseFileLine(String line, String fileName) {
        // Separate the grade field if present
        ContentSpecGrade grade = ContentSpecGrade.UNSPECIFIED;
        String id = line;
        int space = line.indexOf(' ');
        if (space > 0) {
            grade = ContentSpecGrade.fromString(line.substring(0, space));
            if (grade == ContentSpecGrade.UNSPECIFIED) {
                fail("Line has illegal grade value: " + line.substring(0, space));
            }

            id = line.substring(space + 1);
        }

        return Triple.of(grade, id, fileName);
    }

    private static String handleBom(String s) {
        if (s.startsWith(UTF_8_BOM)) {
            return s.substring(UTF_8_BOM.length());
        } else if (s.startsWith(UTF_16_BOM)) {
            return s.substring(UTF_16_BOM.length());
        }
        return s;
    }

    // Legacy IDs frequently are missing the grade. This method adds the grade back
    // so that we can compare it with the round-tripped identifier.
    private String remedyMissingGrade(String id, ContentSpecGrade grade)
    {
        int colon = id.indexOf(':');
        if (colon <= 0) {
            return id;
        }

        int targetPart;
        switch (id.substring(0, colon)) {
            case "SBAC-ELA-v1":
                targetPart = 1;
                break;
            case "SBAC-MA-v4":
            case "SBAC-MA-v5":
                targetPart = 2;
                break;
            case "SBAC-MA-v6":
                targetPart = 3;
                break;
            default:
                return id;
        }

        String[] parts = id.split("\\|");
        if (parts[targetPart].indexOf('-') > 0) {
            return id;
        }

        parts[targetPart] = format("%s-%s", parts[targetPart], grade.getLegacyValue());
        return join("|", parts);
    }

    private static class Counters {
        private int idCount = 0;
        private int errorCount = 0;
        private int legacyFormatCount = 0;
        private int enhancedFormatCount = 0;

        void incrementIdCount() {
            ++idCount;
        }

        void incrementErrorCount() {
            ++errorCount;
        }

        void incrementLegacyFormatCount() {
            ++legacyFormatCount;
        }

        void incrementEnhancedFormatCount() {
            ++enhancedFormatCount;
        }

        @Override
        public String toString() {
            return format("%4d Ids Tested%n", idCount) +
                format("%4d Enhanced Ids%n", enhancedFormatCount) +
                format("%4d Legacy Ids%n", legacyFormatCount) +
                format("%4d Errors Reported%n", errorCount);
        }
    }
}