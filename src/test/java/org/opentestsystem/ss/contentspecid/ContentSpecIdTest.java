package org.opentestsystem.ss.contentspecid;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Triple;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.opentestsystem.ss.contentspecid.enums.ContentSpecClaim;
import org.opentestsystem.ss.contentspecid.enums.ContentSpecGrade;
import org.opentestsystem.ss.contentspecid.enums.ContentSpecFormat;
import org.opentestsystem.ss.contentspecid.exceptions.IdParseException;
import org.opentestsystem.ss.contentspecid.exceptions.IdValidationException;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Stream;

import static java.lang.String.format;
import static java.lang.String.join;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Test of ContentSpecIdConverter against provided test files. All file entries should
 * pass test without errors, and be correctly categorized as enhanced or legacy.
 */
class ContentSpecIdTest {
    private static final String UTF_8_BOM = "\u00EF\u00BB\u00BF";
    private static final String UTF_16_BOM = "\uFEFF";

    private static final String[] TEST_FILES = {
            "LegacyIdsInUse.txt",
            "ElaLegacyIdsFromCoreStandards.txt",
            "MathLegacyIdsFromCoreStandards.txt",
            "ElaEnhancedIdsFromCASE.txt",
            "MathEnhancedIdsFromCASE.txt"
    };

    private static final String RESOURCE_DATA_FOLDER = "/testdata/";
    private static final Map<String, Counters> countersMap = new LinkedHashMap<>();
    private static final ContentSpecIdConverter converter = new ContentSpecIdConverter();

    @BeforeAll
    static void setUpCounters() {
        countersMap.clear();
        for(String fileName : TEST_FILES) {
            countersMap.put(fileName, new Counters());
        }
    }

    @AfterAll
    static void outputCounters() {
        System.out.println("--------------------------------------------------------");
        countersMap.forEach((fileName, counters) -> {
            System.out.println("Testing IDs in " + fileName + ":");
            System.out.println(counters);
            System.out.println("--------------------------------------------------------");
        });
    }

    @ParameterizedTest
    @MethodSource("loadContentSpecIds")
    void shouldParseIds(Triple<ContentSpecGrade,String,String> data) throws Throwable {

        final ContentSpecGrade defaultGrade = data.getLeft();
        final String idString = data.getMiddle();
        final String sourceFile = data.getRight();
        final Counters counters = countersMap.get(sourceFile);
        counters.incrementIdCount();

        try {
            // Parse the ID and check for errors
            ContentSpecFormat format = converter.getFormatType(idString);

            ContentSpecId id;
            if (defaultGrade == null || defaultGrade == ContentSpecGrade.UNSPECIFIED) {
                id = converter.parse(idString);
            } else {
                id = converter.parse(idString, defaultGrade);
            }

            // Check for format-ability
            id.validateFor(format);

            String compId = (format.isLegacy())
                    ? remedyMissingGrade(idString, defaultGrade)
                    : idString;

            // Check for round-trip match
            String roundTrip = converter.format(id, format);
            assertThat("Formatted ID doesn't match: ", roundTrip, is(compId));

            // Check conversions between enhanced and legacy formats
            checkLegacyConversions(id, format, compId);

            if (format.isEnhanced()) {
                counters.incrementEnhancedFormatCount();
            } else {
                counters.incrementLegacyFormatCount();
            }
        } catch (Throwable t) {
            counters.incrementErrorCount();
            throw t;
        }
    }

    private void checkLegacyConversions(final ContentSpecId id, final ContentSpecFormat originalFormat,
                                        final String compId)  {
        // If claim or target is not specified then it cannot be converted to
        // legacy format. Do not perform the test.
        if (originalFormat.isEnhanced()
                && (id.getClaim() == ContentSpecClaim.UNSPECIFIED || isBlank(id.getTarget()))) {
            return;
        }

        // Round-trip through conversion format
        String convertedIdString;
        String reason;

        try {
            if (originalFormat.isEnhanced()) {
                    convertedIdString = converter.formatLegacy(id);
            } else {
                convertedIdString = converter.format(id);
            }
        } catch (IdValidationException e) {
            String toFormat = originalFormat.isEnhanced() ? "legacy" : "enhanced";
            reason = format("Cannot convert ID %s format: %s",
                    toFormat, e.getErrorDescription());
            fail(reason);
            return ; // appeasing the compiler: this line will never be executed. See org.junit.jupiter.api.Assertions
        }

        ContentSpecId convertedId;
        try {
            convertedId = converter.parse(convertedIdString);
        } catch (IdParseException e) {
            reason = format("Cannot parse converted ID %s: %s",
                    convertedIdString, e.getErrorDescription());
            fail(reason);
            return; // appeasing the compiler: this line will never be executed.
        }

        reason = String.format("Converted ID from %s is not equal to original.", convertedIdString);
        assertThat(reason, convertedId, is(id));

        String roundTrip;
        try {
            roundTrip = converter.format(convertedId, originalFormat);
        } catch (IdValidationException e) {
            reason = format("Cannot convert ID back to %s format: %s",
                    originalFormat.getValue(), e.getErrorDescription());
            fail(reason);
            return; // appeasing the compiler: this line will never be executed.
        }

        reason = format("ID %s doesn't match when round-tripped through alternative format: %s",
                convertedIdString, roundTrip);
        assertThat(reason, compId.equalsIgnoreCase(roundTrip));
    }

    private static Stream<Triple<ContentSpecGrade,String,String>> loadContentSpecIds() {
        return Arrays.stream(TEST_FILES)
                .flatMap(ContentSpecIdTest::loadContentSpecIdsFromFile);
    }

    private static Stream<Triple<ContentSpecGrade, String, String>> loadContentSpecIdsFromFile(final String fileName) {
        try {
            return Files
                    .lines(getFile(fileName).toPath())
                    .filter(StringUtils::isNotBlank)
                    .map(String::trim)
                    .filter(line -> !line.startsWith("#"))
//                    .limit(10);
                    .map(ContentSpecIdTest::handleBom)
                    .map(line -> parseFileLine(line, fileName));
        } catch (IOException e) {
            fail("File " + fileName + " not found");
            return Stream.of();
        }
    }

    private static File getFile(String fileName) {
        URL url = Object.class.getResource(RESOURCE_DATA_FOLDER + fileName);
        assertNotNull(url, "File " + fileName + " not found");
        return new File(url.getFile());
    }

    private static Triple<ContentSpecGrade, String, String> parseFileLine(String line, String fileName) {
        // Separate the grade field if present
        ContentSpecGrade grade = ContentSpecGrade.UNSPECIFIED;
        String id = line;
        int space = line.indexOf(' ');
        if (space > 0) {
            grade = ContentSpecGrade.fromString(line.substring(0, space));
            if (grade == ContentSpecGrade.UNSPECIFIED) {
                fail("Line has illegal grade value: " + line.substring(0, space));
            }

            id = line.substring(space + 1);
        }

        return Triple.of(grade, id, fileName);
    }

    private static String handleBom(String s) {
        if (s.startsWith(UTF_8_BOM)) {
            return s.substring(UTF_8_BOM.length());
        } else if (s.startsWith(UTF_16_BOM)) {
            return s.substring(UTF_16_BOM.length());
        }
        return s;
    }

    // Legacy IDs frequently are missing the grade. This method adds the grade back
    // so that we can compare it with the round-tripped identifier.
    private String remedyMissingGrade(String id, ContentSpecGrade grade)
    {
        int colon = id.indexOf(':');
        if (colon <= 0) {
            return id;
        }

        int targetPart;
        switch (id.substring(0, colon)) {
            case "SBAC-ELA-v1":
                targetPart = 1;
                break;
            case "SBAC-MA-v4":
            case "SBAC-MA-v5":
                targetPart = 2;
                break;
            case "SBAC-MA-v6":
                targetPart = 3;
                break;
            default:
                return id;
        }

        String[] parts = id.split("\\|");
        if (parts[targetPart].indexOf('-') > 0) {
            return id;
        }

        parts[targetPart] = format("%s-%s", parts[targetPart], grade.getValue());
        return join("|", parts);
    }

    private static class Counters {
        private int idCount = 0;
        private int errorCount = 0;
        private int legacyFormatCount = 0;
        private int enhancedFormatCount = 0;

        void incrementIdCount() {
            ++idCount;
        }

        void incrementErrorCount() {
            ++errorCount;
        }

        void incrementLegacyFormatCount() {
            ++legacyFormatCount;
        }

        void incrementEnhancedFormatCount() {
            ++enhancedFormatCount;
        }

        @Override
        public String toString() {
            return format("%4d Ids Tested%n", idCount) +
                format("%4d Enhanced Ids%n", enhancedFormatCount) +
                format("%4d Legacy Ids%n", legacyFormatCount) +
                format("%4d Errors Reported%n", errorCount);
        }
    }
}